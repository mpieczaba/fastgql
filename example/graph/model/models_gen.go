// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Character interface {
	IsCharacter()
}

type BooleanComparator struct {
	Eq  *bool `json:"eq"`
	Neq *bool `json:"neq"`
}

type CharacterFilterInput struct {
	ID      *StringComparator     `json:"id"`
	Name    *StringComparator     `json:"name"`
	Friends *CharacterFilterInput `json:"friends"`
	// Logical AND of FilterInput
	And []*CharacterFilterInput `json:"AND"`
	// Logical OR of FilterInput
	Or []*CharacterFilterInput `json:"OR"`
	// Logical NOT of FilterInput
	Not *CharacterFilterInput `json:"NOT"`
}

// Ordering for Character
type CharacterOrdering struct {
	// Order Character by id
	ID *OrderingTypes `json:"id"`
	// Order Character by name
	Name *OrderingTypes `json:"name"`
	// Order Character by appearsIn
	AppearsIn *OrderingTypes `json:"appearsIn"`
}

type Droid struct {
	ID              string      `json:"id"`
	Name            *string     `json:"name"`
	Friends         []Character `json:"friends"`
	AppearsIn       []*Episode  `json:"appearsIn"`
	PrimaryFunction *string     `json:"primaryFunction"`
}

func (Droid) IsCharacter() {}

type DroidFilterInput struct {
	ID              *StringComparator     `json:"id"`
	Name            *StringComparator     `json:"name"`
	Friends         *CharacterFilterInput `json:"friends"`
	PrimaryFunction *StringComparator     `json:"primaryFunction"`
	// Logical AND of FilterInput
	And []*DroidFilterInput `json:"AND"`
	// Logical OR of FilterInput
	Or []*DroidFilterInput `json:"OR"`
	// Logical NOT of FilterInput
	Not *DroidFilterInput `json:"NOT"`
}

type Human struct {
	ID         string      `json:"id"`
	Name       *string     `json:"name"`
	Friends    []Character `json:"friends"`
	AppearsIn  []*Episode  `json:"appearsIn"`
	HomePlanet *string     `json:"homePlanet"`
}

func (Human) IsCharacter() {}

type HumanFilterInput struct {
	ID         *StringComparator     `json:"id"`
	Name       *StringComparator     `json:"name"`
	Friends    *CharacterFilterInput `json:"friends"`
	HomePlanet *StringComparator     `json:"homePlanet"`
	// Logical AND of FilterInput
	And []*HumanFilterInput `json:"AND"`
	// Logical OR of FilterInput
	Or []*HumanFilterInput `json:"OR"`
	// Logical NOT of FilterInput
	Not *HumanFilterInput `json:"NOT"`
}

// Ordering for Human
type HumanOrdering struct {
	// Order Human by id
	ID *OrderingTypes `json:"id"`
	// Order Human by name
	Name *OrderingTypes `json:"name"`
	// Order Human by appearsIn
	AppearsIn *OrderingTypes `json:"appearsIn"`
	// Order Human by homePlanet
	HomePlanet *OrderingTypes `json:"homePlanet"`
}

type IntComparator struct {
	Eq  *int `json:"eq"`
	Neq *int `json:"neq"`
	Gt  *int `json:"gt"`
	Gte *int `json:"gte"`
	Lt  *int `json:"lt"`
	Lte *int `json:"lte"`
}

type IntListComparator struct {
	Eq        []*int `json:"eq"`
	Neq       []*int `json:"neq"`
	Contains  []*int `json:"contains"`
	Contained []*int `json:"contained"`
}

type Operator struct {
	Name OperatorTypes `json:"name"`
	Type *string       `json:"type"`
}

type StringComparator struct {
	Eq          *string   `json:"eq"`
	Neq         *string   `json:"neq"`
	Contains    []*string `json:"contains"`
	NotContains []*string `json:"not_contains"`
	Like        *string   `json:"like"`
	Ilike       *string   `json:"ilike"`
	Suffix      *string   `json:"suffix"`
	Prefix      *string   `json:"prefix"`
}

type Episode string

const (
	EpisodeNewHope Episode = "NEW_HOPE"
	EpisodeEmpire  Episode = "EMPIRE"
	EpisodeJedi    Episode = "JEDI"
)

var AllEpisode = []Episode{
	EpisodeNewHope,
	EpisodeEmpire,
	EpisodeJedi,
}

func (e Episode) IsValid() bool {
	switch e {
	case EpisodeNewHope, EpisodeEmpire, EpisodeJedi:
		return true
	}
	return false
}

func (e Episode) String() string {
	return string(e)
}

func (e *Episode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Episode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Episode", str)
	}
	return nil
}

func (e Episode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperatorTypes string

const (
	OperatorTypesEq    OperatorTypes = "EQ"
	OperatorTypesNeq   OperatorTypes = "NEQ"
	OperatorTypesGt    OperatorTypes = "GT"
	OperatorTypesLt    OperatorTypes = "LT"
	OperatorTypesLte   OperatorTypes = "LTE"
	OperatorTypesGte   OperatorTypes = "GTE"
	OperatorTypesLike  OperatorTypes = "LIKE"
	OperatorTypesIlike OperatorTypes = "ILIKE"
)

var AllOperatorTypes = []OperatorTypes{
	OperatorTypesEq,
	OperatorTypesNeq,
	OperatorTypesGt,
	OperatorTypesLt,
	OperatorTypesLte,
	OperatorTypesGte,
	OperatorTypesLike,
	OperatorTypesIlike,
}

func (e OperatorTypes) IsValid() bool {
	switch e {
	case OperatorTypesEq, OperatorTypesNeq, OperatorTypesGt, OperatorTypesLt, OperatorTypesLte, OperatorTypesGte, OperatorTypesLike, OperatorTypesIlike:
		return true
	}
	return false
}

func (e OperatorTypes) String() string {
	return string(e)
}

func (e *OperatorTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperatorTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperatorTypes", str)
	}
	return nil
}

func (e OperatorTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OrderingTypes string

const (
	OrderingTypesAsc           OrderingTypes = "ASC"
	OrderingTypesDesc          OrderingTypes = "DESC"
	OrderingTypesAscNullFirst  OrderingTypes = "ASC_NULL_FIRST"
	OrderingTypesDescNullFirst OrderingTypes = "DESC_NULL_FIRST"
)

var AllOrderingTypes = []OrderingTypes{
	OrderingTypesAsc,
	OrderingTypesDesc,
	OrderingTypesAscNullFirst,
	OrderingTypesDescNullFirst,
}

func (e OrderingTypes) IsValid() bool {
	switch e {
	case OrderingTypesAsc, OrderingTypesDesc, OrderingTypesAscNullFirst, OrderingTypesDescNullFirst:
		return true
	}
	return false
}

func (e OrderingTypes) String() string {
	return string(e)
}

func (e *OrderingTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderingTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid _OrderingTypes", str)
	}
	return nil
}

func (e OrderingTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RelationType string

const (
	RelationTypeOneToOne   RelationType = "ONE_TO_ONE"
	RelationTypeOneToMany  RelationType = "ONE_TO_MANY"
	RelationTypeManyToMany RelationType = "MANY_TO_MANY"
)

var AllRelationType = []RelationType{
	RelationTypeOneToOne,
	RelationTypeOneToMany,
	RelationTypeManyToMany,
}

func (e RelationType) IsValid() bool {
	switch e {
	case RelationTypeOneToOne, RelationTypeOneToMany, RelationTypeManyToMany:
		return true
	}
	return false
}

func (e RelationType) String() string {
	return string(e)
}

func (e *RelationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RelationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid _relationType", str)
	}
	return nil
}

func (e RelationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
